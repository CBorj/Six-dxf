package com.sixdfx.svglayereditor.laser

import com.sixdfx.svglayereditor.model.SvgLayer
import java.util.regex.Pattern
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sin

/**
 * Conversor de SVG a G-code para láser GRBL
 */
object SvgToGcode {
    
    /**
     * Convierte las capas SVG a G-code según la configuración
     */
    fun convert(
        layers: List<SvgLayer>,
        jobConfig: LaserJobConfig
    ): ConversionResult {
        try {
            val gcode = StringBuilder()
            var totalLines = 0
            var estimatedTime = 0f
            
            // Primero calcular el bounding box global de todas las capas habilitadas
            val enabledConfigs = jobConfig.layerConfigs.filter { it.enabled }
            if (enabledConfigs.isEmpty()) {
                return ConversionResult(
                    success = false,
                    errorMessage = "No hay capas habilitadas para convertir"
                )
            }
            
            // Obtener las capas habilitadas
            val enabledLayers = layers.filter { layer ->
                enabledConfigs.any { it.layerId == layer.id }
            }
            
            // Calcular bounding box global
            val globalBounds = calculateGlobalBoundingBox(enabledLayers)
                ?: return ConversionResult(
                    success = false,
                    errorMessage = "No se pudo calcular el tamaño del diseño"
                )
            
            // Calcular offset de posición
            val (offsetX, offsetY) = jobConfig.position.calculateOffset(
                globalBounds.width,
                globalBounds.height,
                jobConfig.workAreaWidth,
                jobConfig.workAreaHeight
            )
            
            // Header G-code
            gcode.appendLine("; Generated by SVG Layer Editor")
            gcode.appendLine("; Layers: ${enabledConfigs.size}")
            gcode.appendLine("; Work area: ${jobConfig.workAreaWidth} x ${jobConfig.workAreaHeight} mm")
            gcode.appendLine("; Image size: ${String.format("%.2f", globalBounds.width)} x ${String.format("%.2f", globalBounds.height)} mm")
            gcode.appendLine("; Position offset: X=${String.format("%.2f", offsetX)}, Y=${String.format("%.2f", offsetY)}")
            gcode.appendLine()
            gcode.appendLine("G21 ; mm")
            gcode.appendLine("G90 ; absolute positioning")
            gcode.appendLine("G92 X0 Y0 Z0 ; set current position as origin")
            gcode.appendLine("M5 ; laser off")
            gcode.appendLine()
            totalLines += 8
            
            // Procesar cada capa en orden
            for (config in enabledConfigs) {
                val layer = layers.find { it.id == config.layerId } ?: continue
                
                gcode.appendLine("; --- Layer: ${config.layerName} ---")
                gcode.appendLine("; Mode: ${config.mode}, Speed: ${config.speedMmMin} mm/min, Power: ${config.powerPercent}%, Passes: ${config.passes}")
                totalLines += 2
                
                // Extraer paths del SVG
                val paths = extractPaths(layer.xmlContent)
                
                for (pass in 1..config.passes) {
                    if (config.passes > 1) {
                        gcode.appendLine("; Pass $pass of ${config.passes}")
                        totalLines++
                    }
                    
                    for (path in paths) {
                        val pathGcode = when (config.mode) {
                            EngraveMode.LINE -> convertPathToLineGcode(
                                path, config, offsetX, offsetY,
                                globalBounds.minX, globalBounds.minY,
                                jobConfig.maxSValue
                            )
                            EngraveMode.FILL -> convertPathToFillGcode(
                                path, config, offsetX, offsetY,
                                globalBounds.minX, globalBounds.minY,
                                jobConfig.maxSValue
                            )
                        }
                        gcode.append(pathGcode)
                        totalLines += pathGcode.lines().count { it.isNotBlank() }
                        
                        // Estimar tiempo (muy aproximado)
                        estimatedTime += estimatePathTime(pathGcode, config.speedMmMin)
                    }
                }
                
                gcode.appendLine("M5 ; laser off after layer")
                gcode.appendLine()
                totalLines += 2
            }
            
            // Footer G-code
            gcode.appendLine("; --- End ---")
            gcode.appendLine("M5 ; laser off")
            gcode.appendLine("G0 X0 Y0 ; return to origin")
            gcode.appendLine("M2 ; end program")
            totalLines += 4
            
            return ConversionResult(
                success = true,
                gcode = gcode.toString(),
                lineCount = totalLines,
                estimatedTimeMinutes = estimatedTime,
                boundingBox = BoundingBox(
                    offsetX,
                    offsetY,
                    offsetX + globalBounds.width,
                    offsetY + globalBounds.height
                )
            )
            
        } catch (e: Exception) {
            return ConversionResult(
                success = false,
                errorMessage = "Error en conversión: ${e.message}"
            )
        }
    }
    
    /**
     * Calcula el bounding box global de todas las capas
     */
    private fun calculateGlobalBoundingBox(layers: List<SvgLayer>): BoundingBox? {
        var minX = Float.MAX_VALUE
        var minY = Float.MAX_VALUE
        var maxX = Float.MIN_VALUE
        var maxY = Float.MIN_VALUE
        var hasPoints = false
        
        for (layer in layers) {
            val paths = extractPaths(layer.xmlContent)
            for (path in paths) {
                for (point in path.points) {
                    hasPoints = true
                    minX = min(minX, point.x)
                    minY = min(minY, point.y)
                    maxX = max(maxX, point.x)
                    maxY = max(maxY, point.y)
                }
            }
        }
        
        return if (hasPoints) {
            BoundingBox(minX, minY, maxX, maxY)
        } else {
            null
        }
    }
    
    /**
     * Extrae paths de un elemento SVG
     */
    private fun extractPaths(xmlContent: String): List<SvgPath> {
        val paths = mutableListOf<SvgPath>()
        
        // Extraer atributos 'd' de elementos <path>
        val pathPattern = Pattern.compile("<path[^>]*\\sd=[\"']([^\"']*)[\"'][^>]*>", Pattern.CASE_INSENSITIVE)
        val pathMatcher = pathPattern.matcher(xmlContent)
        
        while (pathMatcher.find()) {
            val d = pathMatcher.group(1) ?: continue
            val parsed = parsePathD(d)
            if (parsed.points.isNotEmpty()) {
                paths.add(parsed)
            }
        }
        
        // Extraer rectángulos
        val rectPattern = Pattern.compile("<rect[^>]*>", Pattern.CASE_INSENSITIVE)
        val rectMatcher = rectPattern.matcher(xmlContent)
        
        while (rectMatcher.find()) {
            val rectXml = rectMatcher.group(0)
            val x = extractAttribute(rectXml, "x")?.toFloatOrNull() ?: 0f
            val y = extractAttribute(rectXml, "y")?.toFloatOrNull() ?: 0f
            val width = extractAttribute(rectXml, "width")?.toFloatOrNull() ?: 0f
            val height = extractAttribute(rectXml, "height")?.toFloatOrNull() ?: 0f
            if (width == 0f || height == 0f) continue
            
            paths.add(SvgPath(
                points = listOf(
                    Point2D(x, y),
                    Point2D(x + width, y),
                    Point2D(x + width, y + height),
                    Point2D(x, y + height),
                    Point2D(x, y) // cerrar
                ),
                closed = true
            ))
        }
        
        // Extraer círculos
        val circlePattern = Pattern.compile("<circle[^>]*>", Pattern.CASE_INSENSITIVE)
        val circleMatcher = circlePattern.matcher(xmlContent)
        
        while (circleMatcher.find()) {
            val circleXml = circleMatcher.group(0)
            val cx = extractAttribute(circleXml, "cx")?.toFloatOrNull() ?: 0f
            val cy = extractAttribute(circleXml, "cy")?.toFloatOrNull() ?: 0f
            val r = extractAttribute(circleXml, "r")?.toFloatOrNull() ?: 0f
            if (r == 0f) continue
            
            // Aproximar círculo con polígono
            val points = mutableListOf<Point2D>()
            val segments = 36 // 36 segmentos = 10 grados cada uno
            for (i in 0..segments) {
                val angle = (i * 360.0 / segments) * Math.PI / 180.0
                points.add(Point2D(
                    cx + r * cos(angle).toFloat(),
                    cy + r * sin(angle).toFloat()
                ))
            }
            paths.add(SvgPath(points = points, closed = true))
        }
        
        // Extraer elipses
        val ellipsePattern = Pattern.compile("<ellipse[^>]*>", Pattern.CASE_INSENSITIVE)
        val ellipseMatcher = ellipsePattern.matcher(xmlContent)
        
        while (ellipseMatcher.find()) {
            val ellipseXml = ellipseMatcher.group(0)
            val cx = extractAttribute(ellipseXml, "cx")?.toFloatOrNull() ?: 0f
            val cy = extractAttribute(ellipseXml, "cy")?.toFloatOrNull() ?: 0f
            val rx = extractAttribute(ellipseXml, "rx")?.toFloatOrNull() ?: 0f
            val ry = extractAttribute(ellipseXml, "ry")?.toFloatOrNull() ?: 0f
            if (rx == 0f || ry == 0f) continue
            
            val points = mutableListOf<Point2D>()
            val segments = 36
            for (i in 0..segments) {
                val angle = (i * 360.0 / segments) * Math.PI / 180.0
                points.add(Point2D(
                    cx + rx * cos(angle).toFloat(),
                    cy + ry * sin(angle).toFloat()
                ))
            }
            paths.add(SvgPath(points = points, closed = true))
        }
        
        // Extraer líneas
        val linePattern = Pattern.compile("<line[^>]*>", Pattern.CASE_INSENSITIVE)
        val lineMatcher = linePattern.matcher(xmlContent)
        
        while (lineMatcher.find()) {
            val lineXml = lineMatcher.group(0)
            val x1 = extractAttribute(lineXml, "x1")?.toFloatOrNull() ?: 0f
            val y1 = extractAttribute(lineXml, "y1")?.toFloatOrNull() ?: 0f
            val x2 = extractAttribute(lineXml, "x2")?.toFloatOrNull() ?: 0f
            val y2 = extractAttribute(lineXml, "y2")?.toFloatOrNull() ?: 0f
            
            paths.add(SvgPath(
                points = listOf(Point2D(x1, y1), Point2D(x2, y2)),
                closed = false
            ))
        }
        
        // Extraer polylines
        val polylinePattern = Pattern.compile("<polyline[^>]*\\spoints=[\"']([^\"']*)[\"'][^>]*>", Pattern.CASE_INSENSITIVE)
        val polylineMatcher = polylinePattern.matcher(xmlContent)
        
        while (polylineMatcher.find()) {
            val pointsStr = polylineMatcher.group(1) ?: continue
            val points = parsePolyPoints(pointsStr)
            if (points.isNotEmpty()) {
                paths.add(SvgPath(points = points, closed = false))
            }
        }
        
        // Extraer polygons
        val polygonPattern = Pattern.compile("<polygon[^>]*\\spoints=[\"']([^\"']*)[\"'][^>]*>", Pattern.CASE_INSENSITIVE)
        val polygonMatcher = polygonPattern.matcher(xmlContent)
        
        while (polygonMatcher.find()) {
            val pointsStr = polygonMatcher.group(1) ?: continue
            val points = parsePolyPoints(pointsStr).toMutableList()
            if (points.isNotEmpty()) {
                // Cerrar el polígono
                points.add(points.first())
                paths.add(SvgPath(points = points, closed = true))
            }
        }
        
        return paths
    }
    
    /**
     * Extrae un atributo de un tag XML
     */
    private fun extractAttribute(xml: String?, attrName: String): String? {
        if (xml == null) return null
        val pattern = Pattern.compile("$attrName=[\"']([^\"']*)[\"']", Pattern.CASE_INSENSITIVE)
        val matcher = pattern.matcher(xml)
        return if (matcher.find()) matcher.group(1) else null
    }
    
    /**
     * Parsea puntos de polyline/polygon
     */
    private fun parsePolyPoints(pointsStr: String): List<Point2D> {
        val points = mutableListOf<Point2D>()
        val numbers = pointsStr.trim().split(Regex("[\\s,]+"))
        
        var i = 0
        while (i < numbers.size - 1) {
            val x = numbers[i].toFloatOrNull()
            val y = numbers[i + 1].toFloatOrNull()
            if (x != null && y != null) {
                points.add(Point2D(x, y))
            }
            i += 2
        }
        
        return points
    }
    
    /**
     * Parsea el atributo 'd' de un path SVG
     */
    private fun parsePathD(d: String): SvgPath {
        val points = mutableListOf<Point2D>()
        var currentX = 0f
        var currentY = 0f
        var startX = 0f
        var startY = 0f
        var closed = false
        
        // Tokenizar el path
        val tokens = tokenizePathD(d)
        var i = 0
        
        while (i < tokens.size) {
            val token = tokens[i]
            
            when (token.uppercase()) {
                "M" -> { // MoveTo absoluto
                    if (i + 2 < tokens.size) {
                        currentX = tokens[i + 1].toFloatOrNull() ?: 0f
                        currentY = tokens[i + 2].toFloatOrNull() ?: 0f
                        startX = currentX
                        startY = currentY
                        points.add(Point2D(currentX, currentY))
                        i += 3
                    } else i++
                }
                "m" -> { // MoveTo relativo
                    if (i + 2 < tokens.size) {
                        currentX += tokens[i + 1].toFloatOrNull() ?: 0f
                        currentY += tokens[i + 2].toFloatOrNull() ?: 0f
                        startX = currentX
                        startY = currentY
                        points.add(Point2D(currentX, currentY))
                        i += 3
                    } else i++
                }
                "L" -> { // LineTo absoluto
                    if (i + 2 < tokens.size) {
                        currentX = tokens[i + 1].toFloatOrNull() ?: currentX
                        currentY = tokens[i + 2].toFloatOrNull() ?: currentY
                        points.add(Point2D(currentX, currentY))
                        i += 3
                    } else i++
                }
                "l" -> { // LineTo relativo
                    if (i + 2 < tokens.size) {
                        currentX += tokens[i + 1].toFloatOrNull() ?: 0f
                        currentY += tokens[i + 2].toFloatOrNull() ?: 0f
                        points.add(Point2D(currentX, currentY))
                        i += 3
                    } else i++
                }
                "H" -> { // Horizontal line absoluto
                    if (i + 1 < tokens.size) {
                        currentX = tokens[i + 1].toFloatOrNull() ?: currentX
                        points.add(Point2D(currentX, currentY))
                        i += 2
                    } else i++
                }
                "h" -> { // Horizontal line relativo
                    if (i + 1 < tokens.size) {
                        currentX += tokens[i + 1].toFloatOrNull() ?: 0f
                        points.add(Point2D(currentX, currentY))
                        i += 2
                    } else i++
                }
                "V" -> { // Vertical line absoluto
                    if (i + 1 < tokens.size) {
                        currentY = tokens[i + 1].toFloatOrNull() ?: currentY
                        points.add(Point2D(currentX, currentY))
                        i += 2
                    } else i++
                }
                "v" -> { // Vertical line relativo
                    if (i + 1 < tokens.size) {
                        currentY += tokens[i + 1].toFloatOrNull() ?: 0f
                        points.add(Point2D(currentX, currentY))
                        i += 2
                    } else i++
                }
                "Z", "z" -> { // Close path
                    if (points.isNotEmpty() && (currentX != startX || currentY != startY)) {
                        currentX = startX
                        currentY = startY
                        points.add(Point2D(currentX, currentY))
                    }
                    closed = true
                    i++
                }
                "C" -> { // Curva Bezier cúbica absoluta - simplificamos a puntos
                    if (i + 6 < tokens.size) {
                        // Tomamos el punto final de la curva
                        currentX = tokens[i + 5].toFloatOrNull() ?: currentX
                        currentY = tokens[i + 6].toFloatOrNull() ?: currentY
                        points.add(Point2D(currentX, currentY))
                        i += 7
                    } else i++
                }
                "c" -> { // Curva Bezier cúbica relativa
                    if (i + 6 < tokens.size) {
                        currentX += tokens[i + 5].toFloatOrNull() ?: 0f
                        currentY += tokens[i + 6].toFloatOrNull() ?: 0f
                        points.add(Point2D(currentX, currentY))
                        i += 7
                    } else i++
                }
                "Q" -> { // Curva cuadrática absoluta
                    if (i + 4 < tokens.size) {
                        currentX = tokens[i + 3].toFloatOrNull() ?: currentX
                        currentY = tokens[i + 4].toFloatOrNull() ?: currentY
                        points.add(Point2D(currentX, currentY))
                        i += 5
                    } else i++
                }
                "q" -> { // Curva cuadrática relativa
                    if (i + 4 < tokens.size) {
                        currentX += tokens[i + 3].toFloatOrNull() ?: 0f
                        currentY += tokens[i + 4].toFloatOrNull() ?: 0f
                        points.add(Point2D(currentX, currentY))
                        i += 5
                    } else i++
                }
                "A", "a" -> { // Arco - simplificamos
                    if (i + 7 < tokens.size) {
                        val isRelative = token == "a"
                        val endX = tokens[i + 6].toFloatOrNull() ?: 0f
                        val endY = tokens[i + 7].toFloatOrNull() ?: 0f
                        if (isRelative) {
                            currentX += endX
                            currentY += endY
                        } else {
                            currentX = endX
                            currentY = endY
                        }
                        points.add(Point2D(currentX, currentY))
                        i += 8
                    } else i++
                }
                else -> {
                    // Intentar como número (continuación de comando anterior)
                    i++
                }
            }
        }
        
        return SvgPath(points = points, closed = closed)
    }
    
    /**
     * Tokeniza el atributo 'd' del path
     */
    private fun tokenizePathD(d: String): List<String> {
        val tokens = mutableListOf<String>()
        val current = StringBuilder()
        
        for (char in d) {
            when {
                char.isLetter() -> {
                    if (current.isNotEmpty()) {
                        tokens.add(current.toString().trim())
                        current.clear()
                    }
                    tokens.add(char.toString())
                }
                char == ',' || char == ' ' || char == '\t' || char == '\n' -> {
                    if (current.isNotEmpty()) {
                        tokens.add(current.toString().trim())
                        current.clear()
                    }
                }
                char == '-' && current.isNotEmpty() && !current.endsWith("e") -> {
                    // Nuevo número negativo
                    if (current.isNotEmpty()) {
                        tokens.add(current.toString().trim())
                        current.clear()
                    }
                    current.append(char)
                }
                else -> {
                    current.append(char)
                }
            }
        }
        
        if (current.isNotEmpty()) {
            tokens.add(current.toString().trim())
        }
        
        return tokens.filter { it.isNotBlank() }
    }
    
    /**
     * Convierte un path a G-code en modo línea (vectorial)
     */
    private fun convertPathToLineGcode(
        path: SvgPath,
        config: LayerLaserConfig,
        offsetX: Float,
        offsetY: Float,
        originX: Float,
        originY: Float,
        maxSValue: Int
    ): String {
        if (path.points.isEmpty()) return ""
        
        val gcode = StringBuilder()
        val sValue = config.sValue(maxSValue)
        
        // Primer punto - mover sin láser
        val firstPoint = path.points.first()
        val x0 = offsetX + (firstPoint.x - originX)
        val y0 = offsetY + (firstPoint.y - originY)
        gcode.appendLine("G0 X${format(x0)} Y${format(y0)}")
        
        // Encender láser y dibujar
        gcode.appendLine("M4 S$sValue")
        
        for (i in 1 until path.points.size) {
            val point = path.points[i]
            val x = offsetX + (point.x - originX)
            val y = offsetY + (point.y - originY)
            gcode.appendLine("G1 X${format(x)} Y${format(y)} F${config.speedMmMin}")
        }
        
        gcode.appendLine("M5")
        
        return gcode.toString()
    }
    
    /**
     * Convierte un path a G-code en modo relleno
     */
    private fun convertPathToFillGcode(
        path: SvgPath,
        config: LayerLaserConfig,
        offsetX: Float,
        offsetY: Float,
        originX: Float,
        originY: Float,
        maxSValue: Int
    ): String {
        if (path.points.size < 3 || !path.closed) {
            // Si no es un área cerrada, usar modo línea
            return convertPathToLineGcode(path, config, offsetX, offsetY, originX, originY, maxSValue)
        }
        
        val gcode = StringBuilder()
        val sValue = config.sValue(maxSValue)
        
        // Calcular bounding box del path
        @Suppress("UNUSED_VARIABLE") val minX = path.points.minOf { it.x }
        @Suppress("UNUSED_VARIABLE") val maxX = path.points.maxOf { it.x }
        val minY = path.points.minOf { it.y }
        val maxY = path.points.maxOf { it.y }
        
        // Generar líneas de relleno horizontales
        val spacing = config.fillSpacing.coerceAtLeast(config.accuracy.stepMm)
        var y = minY + spacing
        var leftToRight = true
        
        while (y < maxY) {
            // Encontrar intersecciones con el path
            val intersections = findIntersections(path.points, y)
            
            if (intersections.size >= 2) {
                val sortedX = intersections.sorted()
                
                // Dibujar líneas entre pares de intersecciones
                var i = 0
                while (i < sortedX.size - 1) {
                    val x1 = if (leftToRight) sortedX[i] else sortedX[i + 1]
                    val x2 = if (leftToRight) sortedX[i + 1] else sortedX[i]
                    
                    val gx1 = offsetX + (x1 - originX)
                    val gx2 = offsetX + (x2 - originX)
                    val gy = offsetY + (y - originY)
                    
                    gcode.appendLine("G0 X${format(gx1)} Y${format(gy)}")
                    gcode.appendLine("M4 S$sValue")
                    gcode.appendLine("G1 X${format(gx2)} Y${format(gy)} F${config.speedMmMin}")
                    gcode.appendLine("M5")
                    
                    i += 2
                }
            }
            
            y += spacing
            leftToRight = !leftToRight
        }
        
        // También dibujar el contorno
        gcode.append(convertPathToLineGcode(path, config, offsetX, offsetY, originX, originY, maxSValue))
        
        return gcode.toString()
    }
    
    /**
     * Encuentra intersecciones de una línea horizontal con un polígono
     */
    private fun findIntersections(points: List<Point2D>, y: Float): List<Float> {
        val intersections = mutableListOf<Float>()
        
        for (i in 0 until points.size - 1) {
            val p1 = points[i]
            val p2 = points[i + 1]
            
            // Verificar si la línea horizontal cruza este segmento
            if ((p1.y <= y && p2.y > y) || (p2.y <= y && p1.y > y)) {
                // Calcular X de intersección
                val t = (y - p1.y) / (p2.y - p1.y)
                val x = p1.x + t * (p2.x - p1.x)
                intersections.add(x)
            }
        }
        
        return intersections
    }
    
    /**
     * Estima el tiempo de un path en minutos
     */
    private fun estimatePathTime(gcode: String, speedMmMin: Int): Float {
        var totalDistance = 0f
        var lastX = 0f
        var lastY = 0f
        
        for (line in gcode.lines()) {
            if (line.startsWith("G0") || line.startsWith("G1")) {
                val xMatch = Regex("X(-?\\d+\\.?\\d*)").find(line)
                val yMatch = Regex("Y(-?\\d+\\.?\\d*)").find(line)
                
                val x = xMatch?.groupValues?.get(1)?.toFloatOrNull() ?: lastX
                val y = yMatch?.groupValues?.get(1)?.toFloatOrNull() ?: lastY
                
                val dx = x - lastX
                val dy = y - lastY
                totalDistance += kotlin.math.sqrt(dx * dx + dy * dy)
                
                lastX = x
                lastY = y
            }
        }
        
        return totalDistance / speedMmMin
    }
    
    /**
     * Formatea un número para G-code
     */
    private fun format(value: Float): String {
        return String.format("%.3f", value)
    }
}

/**
 * Representa un path SVG parseado
 */
data class SvgPath(
    val points: List<Point2D>,
    val closed: Boolean
)

/**
 * Punto 2D
 */
data class Point2D(
    val x: Float,
    val y: Float
)
